Let's sum up the last two seminars and get an overview of the problem solving methods we talked about.
We need to answer the following questions for each tecnhique:
    1) Principles
    2) Elements we need to identify/define
    3) Examples of problems that can be solved with technique/known algorithms which use the approach
    4) When to apply? (generally)

--------------------------------------------------------------------

Divide&Conquer
1) Principles

DIVIDE: divide the problem into a number of subproblems that are smaller instances
        of the same problem
CONQUER: conquer the subproblems by solving them recursively; if problem size is small enough,
        solve in straightforward manner
COMBINE: combine the solutions to the subproblems into the solution to the original problem

!! Sometimes we also have to solve subproblems that are not quite the same as the original subproblem
-> we consider it part of the COMBINE step
2) Elements we need to identify/define
Identify:
    -> recursive case
    -> base case
3) Examples

1. Compute the sum of the elements of a given list.

2. Compute sum 1x2 + 2x3 + 3x4 +... + n(n+1).

3. Determine maximum/minimum from a given list.

4. Determine the number of occurrence of a number in a given list.

5. Compute greatest common divisor for the elements in a given list.

6.
4) When to apply?
    -> when problem can be decomposed in simpler subproblems that are of the same type (or
     closely related type)
    -> when the problem can be decomposed in independent subproblems (i.e. they
    are solved separately; solution to one subproblem does not affect solution to
    another subproblem)



---------------------------------------------------------------------
Backtracking

1) Principles
-> Given the formalization of a problem solution as a vector
-> progressively build the solution vector starting from the first element
    and adding next elements, checking if the partial configuration can lead
    to a solution, and going back to the previous element in the solution if
    it cannot
2) Elements we need to identify/define

-> the formalization of the problem solution as a vector
        x = [x1, x2, ..., xn]
-> the search space: x âˆˆ A, A = A1 x A2 x ... x An (cartesian product of sets Ai, i=1,..,n)
    = what values can each of the elements of the solution take?
-> candidate solution = partial configuration that can lead to a solution to the problem
        x = [x1, x2, ..., xk]
        where k = number of elements/components already added to the partial configuration
-> consistent(candidate_solution) function
    = function that checks if a partial configuration (the candidate_solution given as parameter)
            can lead to a solution
-> solution(candidate_solution) function
    = function that checks if the given candidate solution is a solution to the problem


3) Example problems

BT can be applied for problems which fulfill the following conditions:
    -> the solution to the problem can be formalized as a vector(list) [x1, x2, ..., xn],
        where xi takes values from a set Ai, each set Ai is finite


1. Read a word formed from a maximum of 10 distinct lowercase letters. Display the
    anagrams of the read word:
   a) all anagrams, in lexicographic order
   b) anagrams that do not contain two adjacent vowels or two adjacent consonants
            (i.e., vowels and consonants must alternate).

2. Read a natural number n. Generate and display all combinations of 2*n+1 binary digits that
    do not have two adjacent 1 digits.

3. Read a natural number n with at most 9 digits. Display all ways to write n as a product
    of distinct proper divisors of s.

4. Read two natural numbers n and s (n<=10, s<=20). Display in ascending order all
    n-digit numbers whose digit sum is equal to s, and any two adjacent digits have different parity.

5. Read a natural number n. Display the permutations of the set 1,2,...,n in which
   the even elements are fixed points (they are in positions equal to their value).

6. Display all increasing subsequences of length>1 for a given list of n numbers.


4) When to apply?

-> we need to find more than one solution/ALL solutions for a problem
-> suitable for when we need more than one solution or all solutions to
    a problem as it is a method that systematically goes over all possible
    configurations in the search space
-> when high complexity is not an issue - backtracking method has exponential
    time complexity


----------------------------------------------------------------------

Greedy

1) Principles
2) Elements we need to identify/define
3) Examples
4) When to apply?

----------------------------------------------------------------------

Dynamic programming

1) Principles
2) Elements we need to identify/define
3) Examples
4) When to apply?

----------------------------------------------------------------------